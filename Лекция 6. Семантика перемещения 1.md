# Семантика перемещения

## Категории значений (value categories)

### Выражение

* *Выражение* - посл. операций и их операндов, задающ. некторое вычисление.

* Результат выражения проявляется в виде возвращаемого значения `x + y` и/или "побочного эффекта" (`x++`)
* Кажд. выраж. характ. **типом возвращ. значения** и **категорией значения**

###  Value categories

*Категория значения* - вторая характеристика выражения в *C++* (первая - тип)

Категория **отвечает на вопрос**: "*Существует ли результат выражения в виде объекта в памяти или нет?*"

#### Lvalue

*Lvalue* - категория значений, которая обладает идентичностью (но не перемещаема).

<u>Неформально</u>: к *lavalue* относится все, у чего есть постоянное место в памяти. *Lvalue* примеры:

* Переменная - всегда *lvalue*!
* Результат функции/операции, возвращающей ссылку
* Строковый литерал (относится к массиву, который содержит символы)

#### Rvalue

Rvalue - перемещаемая категория значений. 

Бывают:

* prvalue (pure value) - значение без идентичности
* xvalue (expried value) - значение с идентичностью

<u>Неформально</u>:

К rvalue относится все, что не относится к lvalue

Примеры:

* Литералы (кроме строкового)
* Результат функции/операции, возвращающей значение
* `this`
* Значение типа перечисления (`enum`)
* Параметр шаблона, не являющийся типом (если это не ссылка)

## Виды ссылок

* *lvalue*-ссылка - это ссылка, которая **может связываться с результатом lvalue выражения**. Она становится псевдонимом объекта, на который она ссылается.

  Исключение:

  ```c++
  const int& tmp = 11; // 11 располагается в области памяти с именем tmp
  ```

* *rvalue*-ссылка - это ссылка, которая может **связываться с результатом rvalue выражения**. Она позволяет изменять объект.

  Инициализируется через `&&`.

## Перегрузка функций по виду ссылки

Мотивация 1: хотим реализовать ф-ю, которая принимает объект, а возвращает ссылку на него.

**Проблема 1** : когда в ф-ции будем брать адрес, **вернется локальный адрес переданной** переменной (даже по ссылке).

Мотивация 2: Хотим реализовать конструктор для инициализации ссылочного поля.

**Проблема 2**:  Но если передавать в него литерал (не строковый), то все сломается, т.к. у них нет адреса.

#### Решение проблемы 2

Достаточно реализовать дополнительный конструктор, принимающий аргумент по *rvalue*-ссылке и задать его `=default`, тогда будем в случае ошибки получать *CE*, а не *RE*.

## Конструктор перемещения и перемещающее присваивание

**Проблема**:

```c++
Stack<int> stack;
// ...

auto lcopy = stack; // копия stack: O(N)
auto rcopy = Stack<int>(100); // до C++17: создание и копия объекта: O(N) + O(N)

lcopy = stack; // копия lcopy: O(N)
rcopy = Stack<int>(100); // создание и копия временного объекта: O(N) + O(N)
```

#### Решение (конструктор перемещения):

```c++
Stack(Stack&& other) noexcept : buffer_(other.buffer_), size_(other.size_) {
	other.buffer_ = nullptr; // зачем?
	other.size_ = 0; // зачем?
}

Stack& operator=(Stack&& other) noexcept {
	if (this != &other) {
		delete[] buffer_;
		buffer_ = other.buffer_;
		size_ = other.size_;
		other.buffer_ = nullptr; // зачем?
		other.size_ = 0; // зачем?
	}
	return *this;
}

auto rcopy = Stack(100); // до C++17: создание и перемещение: O(N) + O(1)
rcopy = Stack(100); // создание и перемещение: O(N) + O(1)
```

#### Решение (конструктор присваивания):

```c++
Stack(Stack&& other) noexcept : buffer_(other.buffer_), size_(other.size_) {
	other.buffer_ = nullptr; // зачем?
	other.size_ = 0; // зачем?
}

Stack& operator=(Stack&& other) noexcept {
	if (this != &other) {
		delete[] buffer_;
		buffer_ = other.buffer_;
		size_ = other.size_;
		other.buffer_ = nullptr; // зачем?
		other.size_ = 0; // зачем?
	}
	return *this;
}

auto rcopy = Stack(100); // до C++17: создание и перемещение: O(N) + O(1)
rcopy = Stack(100); // создание и перемещение: O(N) + O(1)
```

* Если вы не определили своего копирования, присваивания и деструктора (ничего из этого), то компилятор предоставит вам свой конструктор перемещения для каждого из полей.

* Аналогично для перемещающего присваивания
* Для этих методов можно писать `=default`
* Должны быть `noexcept`!

## Правило пяти (*C++11*)

"Если класс требует реализации хотя бы одного метода из списка: 

1. Конструктор копирования 
2. Конструктор перемещения 
3. Копирующее присваивание
4. Перемещающее присваивание
5. Деструктор

, то требуется реализовать их все"

## `std::move`

* В языке C++ есть преобразование из *lvalue* в *rvalue*

* Это преобразование осуществляется с помощью функции `std::move`.
* `std::move` не меняет состояния объекта. Он лишь просит объект ненадолого притвориться временным (хотя таковым он являться не будет).

* Для результата `std::move` есть специальная категория - *xvalue* (частный случай *rvalue* - перемещаемый и с идентичностью)

# Множественное наследование

Часто возникает потребность создания класса
