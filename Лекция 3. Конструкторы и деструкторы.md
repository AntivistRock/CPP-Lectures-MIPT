# Лекция 3. Конструкторы и деструкторы

<u>Мотивация</u>: 

* Без конструкторов и деструкторов все еще необходимо вручную инициализировать объект и удалять его.
* Нельзя инициализировать константные объекты (именно вызывать метод `.Init()`, это неудобно).
* При копировании создается побитовая копия, то есть, например, все указатели в копии указывают на те же области памяти, что и оригинал.

## Конструкторы

* **Конструктор** - это особый метод класса, который вызывается всякий раз при создании объекта
* Он не имеет возвращаемого значения
* Его имя совпадает с именем класса
* Конструктор вызывается неявно

```c++
class Stack {
    public:
    Stack() {
        buffer_ = new int[kCapacity];
        size_ = 0;
    }
    // ... другие методы
};

Stack stack;
```

Существует несколько видов конструкторов.

### Параметрический конструктор

ПК - это конструктор, который принимает более одного аргумента.

```c++
class Stack {
	public:
	Stack(size_t size, int value) { // стек из size элементов value
		buffer_ = new int[kCapacity];
		size_ = size;
		for (size_t i = 0; i < size_; ++i) {
			buffer_[i] = value;
		}
	}
	// ... (other methods)
};
Stack stack(10, 1);
// или Stack stack = Stack(10, 1);
// или auto stack = Stack(10, 1);
stack.Size(); // 10
stack.Top(); // 1 
```



### Списки инициализации

* В момент выполнения тела конструктора все поля уже должны быть проинициализированы, поэтому надо инициализировать поля до входа в тело конструктора.

  ```c++
  class B {
  	const int x_;
  	double& y_;
  	public:
  	B(int x, double& y) : x_(x), y_(y) { // инициализируем
  	// Работаем с инициализированными данными
  	}
  };
  
  double z = 0.0;
  B b(0, z); // Ok
  ```

  Если список инициализации пуст, то все поля **инициализируется по умолчанию**.

  Если какое-то поле не проинициализировано, компилятор попытается **проинициализировать его самостоятельно**.

* **Важное правило**: порядок создания полей определяется порядком их объявления в классе, а не порядком в списке инициализации.

### Конструктор преобразования

* Конструктор преобразования - это конструктор, который принимает ровно один аргумент.
* Данный конструктор используется для неявных (или явных) преобразований.
* Стандарт *С++11* расширил понятие *“КП”,* но это мы рассматривать не будем

#### Ключевое слово  `explicit`

Чтобы запретить неявные преобразования, необходимо попросить, чтобы они выполнялись только явно.

```c++
explicit Stack::Stack(size_t size) : buffer_(new int[kCapacity]{}), size_(size) { }
Stack stack(1); // Ok: явное преобразование
Stack another = 3; // CE: неявное преобразование
void f(Stack arg);
f(stack); // Ok: нет преобразования
f(10); // CE: неявное преобразование
```

### Конструктор по умолчанию

* Конструктор по умолчанию - конструктор, который может быть вызван без аргументов.

Если вы не объявляете явно ни одного конструктора, то компилятор создаст для класса свой конструктор по умолчанию, который **инициализирует все поля-классы конструкторами по умолчанию, а для полей примитивных типов ничего не делает**.

**Но**, если в классе объявлен хотя бы один конструктор, то никакого неявного конструктора по умолчанию компилятор создавать не будет.

#### Конструкция `= default`

* Если в классе уже есть конструктор, то можно вызвать создание компилятором конструктора по умолчанию с помощью `= default`.
* Такой конструктор эквивалентен конструктору с пустым телом.

```c++
struct B {
	B(int x, int y) {}
	B() = default; // эквивалентно B() {}
};

```

### Конструктор копирования

* КК - конструктор, который создает объект с помощью другого объекта того же типа путем его копирования.

* Единственный аргумент - объект того же типа, который передается по константной ссылке.

  ```c++
  Stack::Stack(const Stack& other) { ... }
  Stack a;
  Stack b(a); // Ok
  ```

  Тогда будет работать следующий код

  ```c++
  const Stack a;
  // ...
  Stack b(a); // Ok
  Stack с(Stack()); // Ok даже до C++17
  ```

Если не объявить конструктор копирования (и конструктора перемещения), то компилятор создаст для класса свой конструктор копирования, который **инициализирует поля-классы их конструкторами копирования, а поля-базовые типы копирует побитово**.

При копировании объекта, у которого вообще нет конструктора копирования, возникает *Compilation Error*.

* Аналогично конструктору по умолчанию, можно явно попросить компилятор создать свою версию конструктора с помощью `= default`

  ```c++
  struct B {
  	B() = default;
  	B(const B&) = default;
  };
  
  B first;
  B second(first); // Ok
  ```

  

* Для создания дефолтного конструктора копирования **недостаточно** определить его пустыми фигурными скобками.

### Делегирование конструкторов

Делегирование конструктора используется для избегания дублирования кода конструкторов, схожих по функционалу

 ```c++
 Stack::Stack(size_t size, const int* values)
 	: buffer_(new int[kCapacity])
 	, size_(size) {
 	for (size_t i = 0; i < size; ++i) {
 		buffer_[i] = values[i];
 	}
 }
 
 Stack::Stack(const Stack& other) : Stack(other.size_, other.buffer_) {
 }
 ```

Проинициализировать отдельные поля по-другому при делегировании конструктора **нельзя**!

## Деструкторы

* Деструктор - особый метод класса при завершении времени жизни объекта.
* Этот метод не имеет возвращаемого значения и аргументов.
* Объявляется как `~<имя класса>`
* Деструктор может быть вызван явно (как метод). Но так делать не стоит.
* Если вы не пишете своего деструктора, то компилятор создаст для класса свой, который **вызывает деструкторы для полей-классов, а для полей-базовых типов ничего не делает**.
* Должен быть с модификатором доступа `public`. Иначе можно создавать объект только в динамической памяти и самим управлять памятью на низком уровне.

```c++
Stack::~Stack() {
	delete[] buffer_;
}

Stack stack;
stack.Push(1);
// Ok, утечек памяти нет
```

* Если невозможно вызвать деструктор у какого-либо поля, то компилятор откажется создавать свой деструктор.
* Чтобы явно использовать деструктор, созданный компилятором, можно использовать `= default`.

Если уничтожение объекта требует освобождения выделенной памяти, закрытия файлов, логирования и т.д., прописывайте эти действия в деструкторе (компилятор не догадается самостоятельно вызвать delete !).

У каждого поля при выходе из тела деструктора вызовется свой деструктор, поэтому вручную уничтожать поля не нужно.

```c++
Stack::~Stack() {
	delete[] buffer_; // Ok
}

struct B {
	Stack s;
	
    ~B() {
		s.~Stack(); // UB: не надо так
	} // <-- деструктор Stack здесь вызовется снова
};
```

## RAII

Конструкторы и деструкторы позволяют реализовать важнейшую идиому языка C++ - **RAII** (Resourse Acquisition Is Initialization / Захват ресурса - это Инициализация)

Идея в том, чтобы выделение и освобождение ресурса происходило автоматически (в конструкторе и деструкторе соотв.)

```c++
// RAII
class IntPtr {
	int* ptr;
	public:
	explicit IntPtr(int value) : ptr(new int(value)) {}
	~IntPtr() { delete ptr; }
	// ...
};
```

## Порядок вызова конструкторов / деструкторов

* Стековые объекты создаются в порядке объявления, а уничтожаются в обратном.

## Правило трёх

Если нужно создать или деструктор, или конструктор копирования, или операции присваивания, то следует реализовать все три объекта.

## Конструкция `= delete` (с++11)

```c++
void f(int);
void f(double) = delete;
template <class T> void g(T);
template <> void g(int) = delete;
// ...
f(1); // Ok
f(1.0); // CE
g(1); // CE
g(1.0); // Ok
```

Функцию `f` нельзя вызывать, а так же нельзя получать указатель на неё.

* Как правило, это используется для запрета генерации некоторых методов (например, запрета копирования).

  ```c++
  struct C {
  	C(const C&) = delete; // теперь к-р 			копирования не может быть вызван
  	// ...
  };
  ```

## Перегрузка операций

Перегрузка операций - механизм, позволяющий определить поведение операций при работе с классами, структурами, перечислениями.

Это пример *статического полиморфизма*.

### Синтаксис

```c++
Complex operator+(const Complex& x, const Complex& y) {
	return Complex(x.re + y.re, x.im + y.im);
}
Complex(1, 2) + Complex(3, 4); // Ok: 4 + 6i
// Эквивалентно operator+(Complex(1, 2), Complex(3, 4))

```

Альтернативно можно объявить операцию как член класса, а не внешнюю функцию.

```c++
Complex Complex::operator+(const Complex& y) const {
	return Complex(re + y.re, im + y.im);
}
Complex(1, 2) + Complex(3, 4); // Ok: 4 + 6i
// Эквивалентно Complex(1, 2).operator+(Complex(3, 4))
```

### Перегрузка унарных операций

```c++
// Реализация в виде внешней функции
Complex operator-(const Complex& x) {
	return {-x.re, -x.im};
}
// Реализация в виде метода класса
Complex Complex::operator-() const {
	return {-re, -im};
}

```

### Правила перегрузки бинарных операций

1. Нельзя переопределять операции с примитивными типами (хотя бы один из аргументов должен быть пользовательского типа)
2. Нельзя вводить новые операции в язык (например, ** для возведения в степень).
3. Нельзя менять арность и приоритет операций.
4. Нельзя переопределять операции `::`,  `.`,  `?:`,  `.*`.
5. Операции `=`, `()`, `[]`, `->` могут быть перегружены только в виде методов.
6. Операции `&&`, `||` теряют свойство “короткого выполнения”, (до *C++17* теряли строгий порядок вычисления вместе с оператором `,`).

### **Особенности перегрузки бинарных операций**

Если есть бинарная операция, то следует реализовывать ее как внешнюю ф-ю, а не как метод класса.

### Перегрузка пре- инкремента и декремента

Операции префиксного инкремента и декремента - унарные операторы, которые изменяют значение переменной на +1/-1 и *возвращают ссылку на ту же переменную*.

Это стоит учитывать при перегрузке операций для своего класса.

```c++
// Так
Complex& operator++(Complex& value) {
	++value.re;
	return value;
}

// Или так
Complex& Complex::operator++() {
	++re;
	return *this;
}
```

### Перегрузка пост- инкремента и декремента

Постфиксный инкремент и декремент возвращают копию старого значения переменной. Для обозначения перегрузки постфиксной операции *надо добавить фиктивный аргумент* `int`.

```c++
// Так
Complex operator++(Complex& value, int) {
	auto old_value = value;
	++value.re;
	return old_value;
}

// Или так
Complex Complex::operator++(int) {
	auto old_value = *this;
	++re;
	return old_value;
}
```

### Перегрузка операции индексирования

Эта операция может быть перегружена только в форме *метода класса* и может иметь *только один аргумент*.

```c++
int IntArray::operator[](size_t i) const { // только для чтения
	return buffer_[i];
}
int& IntArray::operator[](size_t i) { // чтение и запись
	return buffer_[i];
}
// А так нельзя
// int& Matrix::operator[](size_t i, size_t j);

```

### Перегрузка круглых скобок

Эта операция может быть перегружена только в формате *метода класса* и может иметь *<u>сколько угодно аргументов</u>*.

```c++
struct Printer {
	void operator()(int i, const char* str, char c) const {
		std::cout << i << ' ' << str << ' ' << c;
	}
};

Printer print;
print(1, "Hello", '+'); // 1 Hello +

```

### Перегрузка операции присваивания

* Классическая операция присваивания присваивает значение правого аргумента левому аргументу и возвращает ссылку на левый операнд.
* Может быть реализована только как метод класса

```c++
Complex& Complex::operator=(const Complex& other) {
	re = other.re;
	im = other.im;
	return *this
}
```

* Компилятор может создать свой оператор присваивания, который присваивает каждое поле по отдельности и возвращает ссылку

  Т.е. код выше - излишний. Компилятор бы создал то же самое.

* Как и до этого, можно сделать так

  ```c++
  Complex& Complex::operator=(const Complex& other) = default;
  ```

* Если в классе есть нетривиальное управление ресурсами, то необходимо самостоятельно переопределять присваивание (правило трёх).

### Проблема самоприсваивания

Для того, чтобы избежать проблем, возникающих при самоприсваивании, необходимо сделать проверку `if (this != &other) { ... } `

```c++
Stack& Stack::operator=(const Stack& other) {
    if (this != other) {
        
		delete[] buffer_;
		buffer_ = new T[kCapacity];
		size_ = other.size_;
		for (size_t i = 0; i < size_; ++i) {
			buffer_[i] = other.buffer_[i];
		}
		return *this;
    }
}

Stack a;
// ...
a = a;
```

### Составные операции присваивания

Составные операции присваивания имеют вид `+=`, `-=`, `*=` и т.д. В языке *С++* они изменяют левый операнд и *возвращают ссылку на левый операнд*. Как правило, его реализуют как член класса. Считается бинарным оператором.

```c++
// Можно так
Complex& Complex::operator+=(const Complex& other) {
	re += other.re; im += other.im;
	return *this;
}

// А можно так (в отличие от operator=)
Complex& operator+=(Complex& lhs, const Complex& rhs) {
	lhs.re += rhs.re; lhs.im += rhs.im;
	return lhs;
}
```

 

### Перегрузка побитового сдвига

Определим ввод-вывод для класса *Complex*

```c++
std::ostream& operator<<(std::ostream& os, const Complex& value) {
	os << value.re << " + " << value.im << 'i';
	return os;
}

std::istream& operator>>(std::istream& is, Complex& value) {
	is >> value.re >> value.im;
	return is;
}
```

### Ключевое слово `friend`

Если функция объявлена как дружественная к классу, то ей разрешён доступ к *приватным полям этого класса*.

```c++
class Stack {
	// ...
	friend void Print(const Stack& stack);
};

void Print(const Stack& stack) {
	for (size_t i = 0; i < stack.size; ++i) { cout << stack.buffer[i] << ' '; }
}

```

* Другом можно объявлять также методы другого класса, другие классы целиком.

* Друга можно объявить и создать прямо в классе.

Пример реализации потокового ввода для класса *Complex* с приватными полями:

```c++
class Complex {
	double re_;
	double im_;
	// ...
	friend std::istream& operator>>(std::istream& is, Complex& complex);
};

std::istream& operator>>(std::istream& is, Complex& complex) {
	is >> complex.re >> complex.im;
	return is;
}
```
