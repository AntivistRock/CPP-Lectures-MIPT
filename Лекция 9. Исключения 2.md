## Исключения конструкторов и деструкторов

В современном C++ **все деструкторы** по умолчанию помечены как `noexcept`, вылет исключения из деструктора приводит к аварийному завершению программы.

Но если очень хочется, можно написать

```c++
A::~A noexcept(false)
```

### Гарантии безопасности исключений

Гарантия безопасности отвечает на вопрос, в каком состоянии находится система
после возникновения ошибки.

1. Гарантия отсутствия исключений
2. Базовая гарантия безопасности
3. Строгая гарантия безопасности

#### Гарантия отсутствия исключений

Функция удовлетворяет, если она **никогда не бросает исключений**. Т.е. нужно пометить её `noexcept`.

#### Базовая гарантя безопастности

Удовлетворяет, если после возникновения исключения **все компоненты программы находятся в согласованном (валидном состоянии)**, утечки ресурсов не произошло.

#### Строгая гарантия безопасности

Удовлетворяет, если после возникновения исключения **все компоненты программы находятся в том же состоянии**, что и до вызова, **утечки ресурсов не произошло**.

### `noexcept` - для чего реально нужен

* `std::move_if_noexcept()` - делает `std::move`, если конструктор перемещения и перемещающее присваивание являются `noexcept`, иначе ничего не делает.

  ```c++
  new_buffer[i] = std::move_if_noexcept(buffer_[i])
  ```

### Иерархия исключений С++

Хорошая практика - бросать исключения-классы.

При этом чтобы точно знать, какой тип исключения мы ловим, помимо запланированных (т.е. для которых явно написали `catch` блок), мы можем создать класс `Exception`, от которого будут наследоваться все остальные классы-исключения.

Пример:

```c++
class Exception {
	public:
	virtual const char* What() const noexcept { return "Exception"; }
	virtual ~Exception() = default;
};
class DivisionByZero : Exception {
	std::string info_;
	public:
	explicit DivisionByZero(const char* info) noexcept : info_(info) {
	}
	const char* What() const noexcept override {
		return "DivisionByZero";
	}
};

int main() {
	try {
		Divide(1, 0);
	} catch (const Exception& ex) {
		std::cerr << ex.What() << '\n'; // DivisionByZero
	}
}
```

**Но** самое главное, что **все это есть в стандартной библиотеке**!

В *C++* есть готовый базовый класс исключений - `std::exception`. Он содержит единственный виртуальный метод - `what()`.

Так что все *исключения-классы* наследуем от `std::exception`.

### Бонус 1: function try block

Блок `try-catch` можно навесить на функцию целиком (вместе со списком
инициализации).

```c++
void f() try {
	// ...
} catch (std::exception& exception) { /* ... */ }
```

```c++
class B {
	int* ptr_;
	A a_;
	public:
	B() try : ptr_(new int(11)), a_(0) {
		// ...
	} catch (...) {
		delete ptr_; throw;
	}
	// ...
};
```

**Упражнение**: найти **баг** в предложенном решении

### Бонус 2: Метаинформация о функции

Макросы __ func __ , __ LINE __ , __ FILE __ :
https://en.cppreference.com/w/c/language/function_definition
std::source_location (C++20):
https://en.cppreference.com/w/cpp/utility/source_location

Позволяют получить метаинформацию. Можно использовать **для составления информативного исключения**.