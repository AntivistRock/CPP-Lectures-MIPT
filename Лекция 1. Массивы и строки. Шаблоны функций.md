# Лекция 1. Массивы и строки. Шаблоны функций. Ключевое слово auto. Бонус: Агрегатная инициализация.

## Массив

```c++ 
int array[10];
```

**array** - это имя переменной, переменная - именованная область памяти

при этом **array** имеет тип *массив интов размера 10* т.е. **int [10]**. Но массив неявно приводится к указателю, например, при передаче его в функцию, либо при сложении с интом.

Массив нельзя передать по значению.

```c++
void f(int array[50]);

int main() {
    int normal[50];
    f(&normal); // OK
    
    int small[10];
    f(&small); // NOT OK - выходит за границы
    
    int big[100];
    f(&big) // OK - работаем с первыми 50-ю эл-ми
}
```

Для того чтобы исправить это нужно использовать

```c++
void f(int (*array_ptr)[50]); // указатель на массив размера 50
```

либо

```c++
void f(int (&array)[50]); // ссылка
```

1. Нельзя создавать массивы ссылок и массивы функций
2. Нельзя создать массив с неизвестным числом элементов, но можно объявить

```c++
extern int c[]; // объявили массив с неизвестным числом элементов
```

3. При сравнении массивов сравниваются не значения а их адреса.

4. Массивы нельзя присваивать друг другу (исключение - строки при инициализации)

5. Лайфхак: если массив - это поле структуры или класса, то присваивать можно

   ```c++
   struct S {
       int array[3];
   };
   
   S c{1, 2, 3};
   S d{4, 5, 6};
   c = d; // Ok c = {4, 5, 6}
   ```

   

### Динамический массив

Создаются с помощью оператора new[], который возвращает указатель на нулевой элемент массива.

При этом динамический массив не обязан иметь размер константы времени компиляции, т.е. можно написать:

```c++
int n;
std::cin >> n;
int *array = new int[n];
```

## Строки

``` c++
"string"; // имеет тип const char[7]
```

### Строковые литералы

1. Представляют собой массивы символов с **'\0'** на конце
2. Могут быть скопированы при инициализации.
3. Строковые литералы могут сравниваться. Но просто как указатели.

### Строки

Строка - часть массива элементов ```char``` , ограниченная нулевым символом `'\0'`

```c++ 
char yet_another_string = {'k', 'e', 'k'} // - не строка
char yet_another_string = {'k', 'e', 'k', '\0'} // - строка
```

 

## Шаблоны функций

Синтаксис шаблонных функций

* В начале объявляется список шаблонных функций

  ```c++
  template <class T> or template <typename T>
  ```

* Далее следует определение шаблонных функций

  ```c++
  template <class T>
      T Abs(T x) { return x > 0 ? x: -x; }
  ```

* Допустимо использование нескольких шаблонных параметров

  ``` c++
  template <class T, class U>
  ```

  

### Использование шаблонов

```c++
Abs(0.0);
```

При этом могут быть конфликты если T передаются разные типы в одном вызове.

Это решается явным указанием типа приведения в `<>` 

```c++
template <class T>
    T Sum(T x, T, y) { return x + y; }
Sum<long>(1, 1); // OK [T == long]
Sum<double>(1, 0.0); // OK [T == double]
```

Можно так же писать `Sum<int, double>` если у нас объявлено 2 типа в шаблоне (T, U).

### Вывод типа шаблона: передача по значению

``` c++
template <class T>
    void f(T x, T y);
```

При передаче аргумента по значению тип `T` выводится по след. правилам:

1. CV-квалификаторы (const, volatile) игнор.
2. Ссылки отбрасываются (игнорируется категория значения, без разницы, передали lvalue или rvalue, всегда будет приниматься тип Т по значению, как было бы при rvalue)

3. Массивы низводятся до указателей
4. Функц низводятся до указат на функц
5. Типы, соотв одному шаблонному типу Т должны совпадать (после выполн всех действий выше)

### Вывод типа шаблона: передача по ссылке

При передаче по ссылке или указателю низведений типов не происходит.

``` c++
template <class T>
    void f(T& x) { ... }
```

### Параметры шаблона по умолчанию

```c++
template <class T>
    T GetZero() {return 0;}
GetZero(); // CE невозможно вывести тип Т
GetZero<double>(); // OK
```

но можно поступить хитрее:

``` c++
template <class T = int>
    T GetZero() {return 0;}
GetZero(); // OK [T == int]
```

Можно ссылаться на предыдущие шаблонные параметры:

```c++
template <class T, class U = T> // т.е. если тип U вывести невозможно, то
    							// подставь тип T
```

**Важно!** Значения аргументов по умолчанию не могут использоваться для вывода шаблонного типа

```c++
template <class T>
    void f(T x = 0) { ... }
f(); // CE - тип Т не выведен
```

чтобы исправить пишем:

``` c++
template <class T = int>
    void f(T x = 0) { ... }
f(); // OK [T == int]
```

### Инстанцирование шаблона

Инстанцирование функции - создание функции в момент необходимости.

Инстанцирование шаблона - процесс генерации кода из шаблона.

Шаблонные функции создаются лениво, т.е. до тех пор, пока не инициализирована конкретная функция, она не создается, ассемблерный код не генерирования.

Шаблон функции - это **не** функция!

Но при этом можно попросить явно инстанцировать шаблон (даже если не используется)

```c++ 
template <class T>
    void f(T x) { ... }

template void f(float); // явно инстанцируем f<float>
```

### Компиляция шаблона

Она происходит в два этапа:

1. При объявлении проверяется лишь синтаксис языка и условия, которые не зависят от параметра шаблона.
2. Во время инстанцирования происходит полная проверка кода на корректность и генерация машинного кода.

### Перегрузка шаблонов функций

```c++
template <class T, class U>
    int f(T x, U y) { return 1; }

template <class T>
    int f(T x, T y) { return 2; }

int f(int x, int y) { return 3; }
```

Общие правила:

* Точные соответствия всегда побеждают остальные перегрузки.
* Если есть несколько точных соответствий, выигрывает с меньшим числом постановок и приведений типов.
* При прочих равных обычная функция предпочтительнее шаблона.

```c++
f<>(0, 0); // если очень хочется шаблон, а не явную функцию
```

### Специализация шаблона

Шаблонам трудно работать с кастомными типами.

Решение - спец. шаблона.

``` c++
template <class T>
    T abs(T x) { return x > 0 ? x : -x; }
template <>
Complex abs(Complex x) { return {sqrt(x.re * x.re + x.im * x.in), 0}; }
```

Т.е. мы объявили специализацию шаблона для типа Complex. При этом специализация относится к первому шаблону, который выше специализации.

### Non-type template parameters

В качестве шаблонных параметров помимо типов могут выступать еще и:

* Целые числа
* Указатели
* Ссылки
* `std::nullptr`
* Числа с плавающей точкой (С++20)
* Некоторые классы спец вида (С++20)

Пример, когда это нужно:

``` c++
// параметризуем шаблонную функцию типом size_t
template <class T, size_t N>
    size_t ArraySize(const T (&array)[N]) { return N; }

int arr[11];
ArraySize(arr);
```

```c++
// параметризуем шаблонную функцию указателем
template <void (*FPtr)(int)>
void Call(int x) { FPtr(x); }

Call<f>(10); // f - какая-то функция, объявленная ранее
```

## Ключевое слово auto

`auto` используется для автоматического вывода типа переменной при инициализации.

Есть правило `AAA` - *almost always auto*. 

## Бонус: агрегатная инициализация

**Агрегатный тип данных** - это массив, либо класс, в котором нет непубличных нестатических полей, конструкторов и виртуальных методов.

Агрегатный тип можно инициализировать с помощью **агрегатной инициализации** (с помощью фигурных скобок)

```c++
struct S {
    int x;
    double y;
}

S s{1, 0};
int arr[]{1, 2, 3};

S f(S s) {
    return {s.x + 1, s.y + 1}
}

f({0, 0})
```

