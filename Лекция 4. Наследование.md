# Лекция 4. Наследование

Наследование - свойство, позволяющее создать новый тип данных на основе уже существующих с полным или частичным заимствованием функционала.

Для решения проблем дублирования кода и указания связи между классами можно воспользоваться след. синтаксисом:

```c++
struct Hero {
int strength; // сила
int hp; // здоровье
int xp; // опыт
void Heal(); // лечиться
// ... (другие общие методы и поля)
};
struct Archer : public Hero { // лучник унаследован от класса "персонаж"
void Shoot();
// ... (другие специфичные методы и поля)
};
```

`Hero` - базовый класс, `Archer` - производный класс (класс-наследник).

Теперь все поля и `Hero` также являются полями метода класса `Archer`:

```c++
Hero hero;
Archer archer;
hero.hp = 90; // hp - поле hero
archer.hp = 80; // у archer тоже есть такое поле
hero.Heal(); // аналогично
archer.Heal();
archer.Shoot(); // Archer - более специфичный класс
// hero.Shoot(); CE
```

## Модификаторы доступа и наследование

`public` и `private` модификаторы работают как и раньше - public открывает доступ всем, private закрывает доступ для всех, даже для наследников

`public` и `private` могут задавать и *режим наследования*, то есть задавать уровни доступа к полям и методам базового класса.

`public` наследование - все знают о том, что класс унаследован от базового, и внешний код имеет полный доступ у открытым полям и методам базового класса.

`private` наследование - никто не должен знать о наследовании, доступ к открытым полям и методам базового класса имеет только наследник.

```c++
struct Hero {
// ...
};
struct Archer : public Hero { // или struct Archer : private Hero
// ...
};
```

## Модификатор доступа `protected`

Работает так же, как и `private`, но доступ дополнительно получают наследники класса:

```c++
struct A {
protected:
int x;
void f();
};
struct B : public A {
void h() { x = 0; f(); } // Ok
};
A a;
// a.x = 0; a.f(); // CE
B b;
b.h(); // b.x = 0; b.f(); // CE
```

`protected` можно использовать для изменения режима наследования.

`protected` наследование - никто не имеет доступ к базовому классу, кроме наследников.

```c++
struct A {
int x;
void f();
};
struct B : protected A {
};
struct C : public B {
void h() { x = 0; f(); } // Ok
};
A a; a.x = 0; a.f();
B b; // b.x = 0; b.f() // CE
```

При этом наследование от унаследованного класса считается "внешним кодом".

## TL;DR

`public` режим наследования позволяет обращаться к полям и методам базового класса напрямую (то есть пользоваться наследником в точности как базовым классом). Реализует семантику "является".

```c++
struct A { /* ... */ };
struct B : public A { /* ... */ }; // B является A
```

`private` и `protected` режимы запрещают внешнему коду (кроме друзей) каким-то образом использовать знание о том, что что-то от чего-то унаследовано. `protected` дополнительно разрешает доступ для наследников класса (для всех остальных работает как `private`). Реализует семантику "содержит".

## Замечание о `private` и `protected` наследовании

`private` и `protected` наследование почти всегда можно заменить на композицию (введение поля нужного типа в класс):

```c++
struct A { /* ... */ };

struct B : private A { /* ... */ };

struct C {
private:
A a;
// ...
};
```

Классы `C`и `B` практически эквивалентны (с точки зрения внешнего кода эквивалентны, так как он не использует факт наследования от `A` или наличия поля `a` ). 

## Empty Base Optimization (EBO)

Размер в байтах любого, даже пустого, объекта в *C++* обязан быть > 0. Однако при наследовании от пустого класса размер наследника не увеличивается.

```c++
struct A {}; // sizeof(A) == 1
struct B : private A { // sizeof(B) == sizeof(int)
int x;
};
struct C { // sizeof(C) > sizeof(int)
int x;
private:
A a;
};
```

## Ещё одно отличие `class` от `struct`

Классы по умолчанию наследуют приватно, а структуры - публично.

```c++
class A { /* ... */ };
struct S : A { /* ... */ };
// <=>
struct S : public A { /* ... */ };
class C : A { /* ... */ };
// <=>
class C : private A { /* ... */ };
```

Больше отличий (кроме уже известных) нет.

## Порядок вызова конструкторов и деструкторов при наследовании

Перед входом в тело конструктора все поля и *базовые классы* должны быть <u>проинициализированы</u>.

При вызове конструктора у наследника, мы можем вызвать в списке инициализации нужный нам конструктор базового класса.

```c++
class StackMax : public Stack {
	int max_buffer_ = nullptr;
	public:
	StackMax() = default; // Stack()
	StackMax(const StackMax& other)
		: Stack(other), max_buffer_(new int[kCapacity]) {
		
    	if (size_ > 0) {
			max_buffer_[0] = buffer_[0];
		}
		for (size_t i = 1; i < size; ++i) {
			max_buffer_[i] = std::max(buffer_[i], max_buffer_[i - 1]);
		}
	}
	// ...
};
```

* Класс инициализируется в следующем порядке: сначала инициализируются *базовые классы*, затем поля *класса-наследника* в порядке объявления (список инициализации не может повлиять на порядок!)

  ```c++
  struct A {
  	int x;
  	int y;
  	A(int);
  	A(int, int);
  };
  
  struct B : public A {
  	int z = 0;
  
  	// B() {} - CE, у A нет конструктора по умолчанию
  	B(int x) : A(x) {}
  	B(int x, int y) : A(x, y) {} // сначала A(x, y), затем z = 0
  	B(int x, int y, int z) : A(x, y), z(z) {}
  }
  ```

  

* Чтобы не дублировать конструкторы базового класса (как в прошлом примере) можно воспользоваться конструкцией `using A::A` (теперь `B` можно создавать так же как и `A` ).

  ```c++
  struct A {
  	int x;
  	int y;
  	A(int);
  	A(int, int);
  };
  
  struct B : public A {
  	int z = 0;
      
  	using A::A;
  	B(int x, int y, int z) : A(x, y), z(z) {}
  }
  ```

* Нельзя проинициализировать отдельное поле *базового класса*, только всю базовую часть <u>целиком</u>.

  ```c++
  struct A {
  	int x;
  	int y;
  	A(int);
  	A(int, int);
  };
  
  struct B : public A {
  	int z = 0;
  	B(int x, int y, int z) : x(x), y(y), z(z) {} // CE
  }
  ```

  ```tex
  error: class 'B' does not have any field named 'x'
  error: class 'B' does not have any field named 'y' 
  ```

### Порядок вызова деструкторов

При уничтожении объекта сначала выполняется *тело деструктора*, затем деструктурируются поля *класса-наследника* в порядке обратном объявлению и в самом конце уничтожаются части базового класса.

## Срезка (Slicing)

Можно инициализировать объекты предка объектами потомков, а также присваивать предкам потомков. Но не наоборот!

```c++
struct A {
	int x;
	void f();
};

struct B : public A { // B является A (но A не является B)
	int y;
	void g();
};

B b;
A a = B();
a = b;
// b = a; // CE
```

Эта возможность называется *срезкой* (при присваивании используются только часть класса, относящаяся к базовому классу).

> Стоит отметить, что если в базовом классе есть копирующий/перемещающий конструктор/присваивание, то при срезке будут использованы именно они.

* При приватном и защищенном наследовании внешний код не имеет права использовать факт наличия связи между классами, поэтому срезка запрещена.

  ```c++
  struct A { /* ... */ };
  struct B : protected A { /* ... */ };
  
  // A a = B(); // CE
  ```

  **Исключение 1**: внутри класса-наследника срезку делать можно (он "знает" про то, что он от чего-то унаследован)

  ```c++
  struct B : protected A {
  	void f() { A a = B(); } // Ok
  };
  ```

  **Исключение 2**: друзья наследника тоже имеют право знать (и использовать) факт наследования

### Настройка поведения при срезке

Для задания конкретного поведения нужно определить конструктор `A` от `B`:

```c++
struct B; // forward declaration

struct A {
	std::string name = "A";
	A(const B& other);
	// ...
};

struct B : public A {
	// ...
};

A::A(const B& other) : name("A") { /* ... */ }
```

```c++
A aa = b; aa.name; // "A"
```

Аналогичным образом можно запретить срезку:

```c++
struct B; // forward declaration

struct A {
	std::string name = "A";
	A(const B& other) = delete;
	// ...
};

struct B : public A {
	// ...
};
```

```c++
A aa = b; // CE
```

## Затенение методов базового класса (shadowing)

Если в производном классе присутствует метод с тем же именем, что и метод в базовом классе, то это имя затеняет базовые методы с тем же именем (shadowing).

Есть несколько решений этой "проблемы" (не факт, что проблема):

1. Смириться

2. Использовать полное имя метода (`b.A::f()`).

3. Ввести имена базового класса в область производного класса с помощью `using`:

   ```c++
   struct A {
   	void f();
   	void f(double);
   };
   
   struct B : public A {
   	using A::f; // A::f(), A::f(double) (частично нельзя!)
   	void f(int);
   };
   
   b.f(0); // Ok: B::f(int)
   b.f(); // Ok: A::f()
   b.f(0.0); // Ok: A::f(double)
   ```

   

## Работа с производным классом через указатель или ссылку на базовый

### Указатель и ссылка на базовый класс

```c++
class B : public A { /* ... */ };
```

Если класс `B` публично унаследован от класса `A` , можно (подобно срезке) присваивать указатель/ссылку на `B` указателю/ссылке на `A`:

```c++
B b;
A* b_ptr = &b; // Ok
A& b_ref = b; // Ok
```

Но не наоборот:

```c++
A a;
B* a_ptr = &a; // CE
B& a_ref = a; // CE
```

### Отличие от срезки

Указатель или ссылка ссылаются на тот же объект и работают с его данными, в отличие от срезки, где мы работаем с копией.

### Какие методы вызываются

Компилятор выбирает версию метода, основываясь на статическом типе указателя/ссылки, не обращая внимания на реальный тип объекта, на который ссылаются.