# Исключения

 Для обработки ошибок в *C++* используется *механизм ошибок*.

## Оператор `throw`

После выполнения throw работа функции прекращается, для объектов на стеке вызываются деструкторы, как и для всей последовательности вызовов, приведшей к ошибке.

```c++
throw <obj>
```

Объект исключения хранится в специальном месте памяти и создается путем
копирования или перемещения переданного объекта.

```c++
A a;
throw a; // Создается исключение A как копия оъекта a
throw std::move(a); // Объект исключения создается с помощью перемещения
```

При бросании prvalue происходит copy elision (C++17):

```c++
throw A(); // вызывается конструктор по умолчанию, без copy или move
```

### `try`-`catch` блок

```c++
template <class T>
T Divide(T x, T y) {
	if (y == 0) { throw 1; }
	return x / y;
}

int main() {
	try {
	Divide(1, 0);
} catch (int err) {
	std::cout << "DivisionError: error code " << err << '\n';
}
	return 0;
}
```

Обработка происходит след. образом:

```c++
int main() {
try {
	Divide(1, 0);
	std::cout << "Java is better than C++\n"; // <- это не выведется
} catch (int err) {
	std::cout << "DivisionError: error code " << err << '\n';
}
	return 0;
}
```

Возникающее в блоке `try` исключение может быть поймано в `catch` блоке соответствующего типа.
По завершении блока `catch` исключение считается успешно обработанным и выполнение программы продолжается в нормальном режиме.

* Одному блоку `try` может соответствовать несколько блоков `catch`

* Блок `catch` выбирается только по *точному соответствию*. То есть приведений типов **НЕ** происходит.

  Но есть 2 исключения:

  * `void*` может поймать любой указатель.

    ```c++
    void f() {
    	int x;
    	try { throw &x; }
    	catch (void* ptr) { std::cout << "catched\n"; }
    }
    ```

  * Приведения по иерархии наследования вверх (к родителям) работают.

    ```c++
    class B : public A {};
    
    void f() {
    	try { throw B(); }
    	catch (A a) { std::cout << "catched\n"; }
    }
    ```

* Срабатывает всегда **первый подходящий** `catch`.

* Если ловить исключение по значению, то **исходное исключение скопируется**.

  Чтобы избежать копирования можно ловить **исключения по ссылке** (или по константной ссылке).

  ```c++
  void f() {
  	try { throw std::vector<int>(1'000'000); }
  	catch (const std::vector<int>& v) {}
  }
  ```

#### `catch (...)`

Позволяет поймать любое исключение. Но нельзя определить тип исключения и поработать с объектом исключения.

#### `throw;`

Дословно означает: *"снова бросить пойманное исключение"*. При этом **копии**
исключения **не создается** - будет "ле теть" тот же объект, что и раньше.

### RAII и исключения

Главный довод в пользу использования RAII классов - они сами вызывают исключения при необходимости.

## Статическая спецификация исключений (*C++11*)

`noexcept` - спецификатор, показывающий, что функция не бросает исключение (если все же бросит, то программа завершится аварийно). При этом в самой `noexcept` функции бросать и обрабатывать исключения можно.

#### Условный спецификатор `noexcept` (*C++11*)

Пример:

```c++
template <class T>
void h(T x) noexcept(sizeof(T) > 1);
```

Ключевое слово `noexcept` еще служит для обозначения операции, которая определяет является ли выражение *noexcept* или нет:

```c++
void f() noexcept;
void g();
noexcept(f()); // true
noexcept(g()); // false

std::vector<int> v;
noexcept(1 / 0); // true - деление целых чисел не генерирует исключений!
noexcept(v.push_back(1 / 0)); // false - push_back может бросить out_of_memory
```

### Небросающий `new`

Использование new небезопасно с точки зрения возможных исключений - если недостаточно памяти, то вылетает исключение типа `std::out_of_memory`.

```c++
auto ptr = new int[1'000'000]; // потенциально может бросить исключение
```

Это поведение можно изменить - можно попросить вместо исключения возвращать `nullptr` с помощью следующего синтаксиса:

```c++
auto ptr = new(std::nothrow) int[1'000'000];
if (!ptr) { /* памяти не хватило */ }
```
