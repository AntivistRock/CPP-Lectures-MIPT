# Лекция 2. Введение в ООП. Шаблоны классов.

## Парадигма программирования

* **ПП** - это совокупность идей и понятий, определяющих стиль программы компьютерных программ.
* Служит для упрощения разработки и поддержки программ.
* При проектировании и написании кода парадигма отвечает на вопрос "как?".
* Язык программирования может поддерживать сразу несколько парадигм.

### Основные парадигмы

* **Императивное программирование** - программирование с описанием последовательности инструкций, ветвлений, безусловных переходов, иногда с вызовом подпрограмм.
* **Структурное программирование** - программирование с использованием независимых логически законченных процедур/функций.
* **Объектно-ориентированное программирование** - парадигма, основанная на представлении программы в виде совокупности классов, объектов и их взаимодействий.

### Основные принципы ООП

* **Абстракция** - выделение наиболее важных свойств объектов реального мира и их оформление в виде атрибутов класса.
* **Инкапсуляция** - объединение данных и методов для работы с ними в рамках одного объекта, возможно, с ограничением доступа к деталям реализации (сокрытие данных).
* **Полиморфизм** - свойство системы, позволяющее использовать различные реализации в рамках одного интерфейса (один интерфейс - много реализаций). 
* **Наследование** - свойство, позволяющее создавать новый тип данных на основе уже существующего, с полным или частичным заимствованием функционала.

### Классы и объекты

**Класс** - описание некоторого концепта из предметной области в виде набора полей и методов для работы с ними (описание нового типа данных).

### Модификаторы доступа

``` c++
struct Stack {
    // public:
    // ...
    private:
    // ...
    public:
    // ...
}
```

Типы модификаторов:

* **public** - любой внешний по отношению к классу код имеет доступ к полям и методам.
* **private** - доступ имеют *только* поля и методы класса, а также дружественные функции и классы.
* **protected** - то же самое, что и `private`, но дополнительно доступ получают и наследники класса.
* Располагать модификаторы доступа внутри класса можно в любом порядке и в любом количестве.
* Модификатор действует с точки объявления до следующего модификатора доступа (либо конца класса).

### Ключевое слово `class`

```c++
class Stack {
    // ...
}
```

* Классы полностью эквивалентны структурам, но есть два нюанса:
  1. В классах модификатор доступа по умолчанию `private`,  в структурах - `public`.
  2. Классы наследуют по умолчанию приватным образом, структуры - публичным.

* Как правило, предпочитают использовать `class`. Структуры обычно пишут без методов, и они состоят только из открытых полей базовых типов (POD - типы)

### Определение вне классов

* Методы можно определять вне классов, при этом они все еще должны быть предварительно объявлены в теле класса.

  ```c++
  struct S {
      int x = 0;
      void f();
  };
  
  void S::f() { std::cout << x; }
  ```

* При определении методов внутри класса они автоматически становятся `inline`. Это помогает обойти *правило одного определения*.

  ```c++
  struct S {
      int x = 0;
      
      void f() { std::cout << x; } // inline
  }
  ```

### Getter и Setter

Setter - устанавливает нужное значение в закрытом поле.

Getter - считывает значение из закрытого поля.

```c++
class C {
    int x;
    public:
    int GetX() { return x; } // Getter
};
```

### Константные поля

* Как и любую переменную, поле можно объявить константным.

  ```c++
  struct S {
      const int size = 0;
  };
  ```

* Такие поля нужно инициализировать сразу в теле структуры или класса.

* В течение жизни они не меняют своего значения.

### Константные методы

Если мы создаем константный класс, то обязаны объявить константные методы для работы с ним. Это делается с помощью `const` после прототипа функции.

```c++
int Stack::Size() const {
    return size;
}

Stack s;

const Stack& cref = s;
cref.Size();
```

Важно:

* Нельзя менять поля класса в константных методах.
* Нельзя вызывать неконстантные методы из константного.

Это порождает CE.

Константность является частью сигнатуры метода, поэтому по константности можно делать перегрузку. Одна ф-я будет работать с константными классами, другая с неконстантными.

### Статические поля и методы

* С помощью ключевого слова `static` некоторые поля и методы можно сделать статическими.

  ```c++
  struct S {
      int x;
      static int y;
      
      void f();
      static void g();
  };
  ```

* Такие поля и методы принадлежат не конкретному объекту, а классу в целом.

* К ним можно обращаться не только через объект класса, но и через имя класса с помощью операции `::` (`S::y` или `S::g()`).

* Статические методы могут работать только со статическими полями.

  #### Замечание о статических полях

  Начальное значение статического поля должно быть задано явно.

  ```c++
  struct S {
      static int x; // Linker error
  };
  ```

  Но его нельзя задавать внутри класса (нарушение ODR).

  ```c++
  static S {
      static int x = 0; // Compilation error
  }
  ```

  Исключением являются константные целочисленные статические поля.

  ```c++
  struct S {
      const static int x = 0; // OK
  }
  ```

  В общем случае инициализировать статическое поле нужно **вне класса** и **ровно в одном** `.cpp` **файле**.

  ```c++
  struct S {
      static int x;
  };
  
  int S::x = 0; // OK
  ```

### Константные статические методы

Их нет, т.к. они бессмысленны.

### Ключевое слово `this`

Значение ключевого слова `this` - адрес текущего объекта.

``` c++
struct S {
    int x;
    
    void SetX(int value) {
        this->x = value; // <=> x = value;
    }
    
    int GetX() {
        return this->x; // <=> return x;
    }
    
    S* GetAddress() {
        return this;
    }
};

S s;
&s == s.GetAddress(); // true
```

Обращение к полям класса неявно происходит через `this`.

`this` имеет тип **указателя** в неконстантных объектах и **указатель на константу** в константных объектах.

### Логическая и физическая константность

* Объект **логически константен**, если с точки зрения пользователя объект не меняет своего состояния (нельзя отличить объект до и после операции).
* Объект **физически константен**, если его внутреннее представление никак не меняется (не изменилось ни одного бита внутри объекта).

#### Ключевое слово `mutable`

* Чтобы сообщить компилятору, что изменение данного поля не влияет на логическую константность объекта, его можно пометить ключевым словом `mutable`.

* `mutable` поля можно изменять в константных методах

  Это бывает нужно, например, для внутреннего логирования вызовов методов.

``` c++
class C {
    mutable int counter = 0;
    
    public:
    int GetZero() const {
        ++counter;
        return 0;
    }
};

const C c;
c.GetZero(); // OK
```

## Шаблоны классов

* В отличие от обычных классов, можно объявлять только в области видимости пространства имен, либо внутри другого класса.

* Тип шаблонного параметра нужно указывать явно (С++17: если невозможно вывести тип по конструктору).

  ```c++
  template <class T>
      struct S {
          void f();
          void g();
      }
  
  S<int> s; // явно указываем тип int
  ```

  

* Шаблоны классов (как и другие шаблоны) инстанцируются “лениво”. Более того, методы шаблонного класса тоже инстанцируются “лениво”.

### Синтаксис шаблонов классов

``` c++
template <class T>
    class Stack {
        T* buffer_;
        size_t size_;
        
        public:
        void Push(T value);
        void Pop();
        size_t Size() const;
        // ...
    };
Stack<int> stack_int; // [T == int]
Stack<double> stack_double; // [T == double]

stack_int.Push(1); // 1
stack_double.Push(1); // 1.0
```

### Специализация шаблонов классов

```c++
// общий шаблон
template <class T>
    struct IsInt {
        static const bool value = false;
    };

// полная специализация
template <class T>
    struct IsInt<int> {
        static const bool value = true;
    };
```

Как и в случае шаблонов функций, шаблоны и специализации могут кардинально отличаться (разные поля, разные методы). 

### Частичная специализация шаблонов классов

Иногда хочется задать определенное поведение класса не для конкретного типа, а для целого семейства типов (например, для указателей).

```c++
template <class T> // общий шаблон
    struct IsPointer {
        static const bool value = false;
        static bool IsIntPointer() { return false; }
    };

template <class T> // частичная специализация
    struct IsPointer<T*> {
        static const bool value = true;
        static bool IsIntPointer() { return false; }
    };

template <class T> // полная специализация
    struct IsPointer<int*> {
        static const bool value = true;
        static bool IsIntPointer() { return true; }
    };
```

* Если имеется, например, 2 типа в шаблоне, но при этом мы указываем явно только один из них, то это тоже считается частичной специализацией.

### Частичная специализация шаблонов функций

Её **не** **существует**.

### Шаблонные параметры шаблонов

Шаблон может принимать другие шаблоны в качестве параметров

```c++
template <class T>
    class Array {
        // ...
    };
// шаблон принимающий тип и шаблон, принимающий тип
template <class T, template <class> class Container>
    class Stack {
        Container<T> buffer;
        public:
        // ...
    };

Stack<int, Array> stack;
```

## Шаблоны переменных

Рекомендация лектора, где почитать про шаблоны ещё: *C++ Templates The Complete Guide* Vondervoorde.

В *С++14* появились шаблоны переменных.

```c++
tempate <class T> // общий шаблон
    const T kZero = 0;

template <> // специализация
	const Complex kZero<Complex> = {0, 0};

auto x = kZero<int>;
auto y = kZero<double>;
auto z = kZero<Complex>;
```

* Шаблонная переменная может быть объявлена только в глобальной области видимости (или области некоторого пространства имён), либо внутри класса, но тогда должна быть статической.
* Шаблонная переменная должна быть сразу определена (за исключением статического поля класса).
* Как и шаблоны функций, шаблоны переменных инстанцируются “лениво”.
* Шаблоны переменных могут быть полностью или частично специализированы.

## Псевдонимы типов

### `typedef`

`typedef` позволяет объявить псевдоним для некоторого существующего типа.

```c++
typedef long long ll;
long long x = 0;
ll y = 0 // ll == long long
```

Пишем `<имя типа>` `<имя псевдонима>` и в любое место до имени псевдонима вставить слово `typedef`

Можно объявить несколько псевдонимов для одного типа в одной строке и даже для его комбинаций.

```c++
typedef int int1_t, int2_t; // оба - псевдонимы int

typedef int* int_ptr_t; // int_ptr_t == int*
typedef int int10_t[10]; // int10_t == int[10]
typedef int func_int2int(int); // func int2int == int(int)

// то же самое в одну строку
typedef int int_t, *int_ptr_t, int10_t[10], func_int2int(int);
```

* Альтернативный способ - писать `using <имя типа> = <псевдоним>`.

### Типы-члены класса

Псевдоним можно объявить внутри класса, тогда он станет типом-членом этого класса

```c++
struct S {
    typedef int int_t;
    private:
    using long_t = long;
};

S::int_t x = 0; // OK
S::long_t y = 0; // CE
```

### Шаблон псевдонима

