# Виртуальные функции

Добавим `virtual` перед объявлением метода в классе `A`:

```c++
struct A {
	virtual void f() { std::cout << "A::f()\n"; }
};

struct B : public A {
	void f() {std::cout << "B::f()\n"; } // <-- автоматически virtual!
};

B b;
A* b_ptr = &b;
b_ptr->f(); // B::f()
```

## `Virtual`: позднее связывание

`virtual` перед объявлением метода говорит, что решение о том, какую версию метода выбрать, должно быть принято во время исполнения программы (**позднее связывание**), а не на этапе компиялции (**раннее связывание**).

```c++
struct A {
	virtual void f() { std::cout << "A::f()\n"; }
	void g() { std::cout << "A::g()\n"; }
};

struct B : public A {
	void f() { std::cout << "B::f()\n"; } // <-- автоматически virtual!
	void g() { std::cout << "B::g()\n"; }
};

A* ptr = new B;
ptr->g(); // во время компиляции "подставляется" вызов A::g
ptr->f(); // решение откладывается до момента исполнения программы
```

Нужно т.к. бывает, что выбор функции зависит от введенного пользователем значениея, которое мы не знаем на этапе компиляции.

* Виртуальность можно использовать внутри методов.
* В конструкторах и деструкторах не работают. При их вызове виртуальность игнорируется.

## Динамический полиморфизм

* **Статический полиморфизм** - вид полиморфизма, при котором выбор реализации осуществляется на этапе компиляции (перегрузка функций, шаблоны, перегрузка операций и т.д.)

* **Динамический полиморфизм** - вид полиморфизма, при котором выбор реализации осуществляется во время выполнения программы.
  * В *С++* основной механизм его реализации - **виртуальные функции**.
  * Наследование с применением виртуальных функций называют **полиморфным**.

## Виртуальный деструктор

Если вы предполагаете, что ваш класс будет базовым для некоторых классов, то в нем стоит делать <u>виртуальный деструктор</u>, чтобы при удалелении объекта, выбор деструктора происходит во время работы программы.

## `override` & `final`

* `override` - позволяет получить *CE*, если вдруг мы не переопределяем помеценную функцию.

  ```c++
  struct A {
      virtual void f(int);
      void g() const;
  };
  
  struct B : public A {
      void f(int) override; // OK
      void g() override; // CE т.к. в базовом классе g константная, и получается мы определяем новую функцию, 		
  };    				   // а не переопределяем виртуальную
  
  ```

* `final` - позволяет запретить дальнейшее переопределение помеченной функции

  ```c++
  struct A {
      virtual void f();
  };
  
  struct B : public A {
      void f() final;
  };
  
  struct C : public B {
      void f(); // CE
  };
  ```

  При этом если определить *виртуальную функцию*, сразу пометив ее `final`, в дальнейшем <u>будет запрещено создавать функции с таким же именем и аргументами</u>.

  `final` можно использовать и при определении класса, чтобы запретить от него наследоваться:

  ```c++
  struct A {
      //
  };
  
  struct B final : public A {
      //
  };
  
  struct C : public B {}; // CE
  ```


## Ковариантные возвращаемые типы

Тип виртуальной функции и ее переопределение должны быть равны с точностью до *ковариантных* возвращаемых типов.

**Ковариантные типы** - такие, что они являются указателями или ссылками и ссылаются на родственные классы (предок-потомок).

## Чисто виртуальные функции и абстрактные классы

* **Абстрактный класс** - класс, который имеет *метод интерфейса*, т.е. *чисто виртуальный метод*. (возможно определение не совсем корректное)
  
  * Его нельзя создать.
  * Можно создать на него ссылку или указатель.
  * Если наследник не переопределил чисто виртуальный метод, то сам наследник становится абстрактным классом.
  * Вызов чисто виртуального метода в конструкторе / деструкторе абстрактного класса приводит к *udefinied behaviour*.
  * Используются для определения интерфейса, создания семейства классов с одинаковыми свойствами
  
* **Метод интерфейса / чисто виртуальная функция** - методы/функции, которые могут не иметь реализации. Определяются через `= 0` на конце:

  ```c++
  class Message {
      virtual void Display() const = 0;
  }
  ```

  **!!!** **Чисто виртуальные функции** могут быть реализованы **только вне класса**.

## Таблица виртуальных функций

* Создается отдельно для каждого класса, если в нем объявлена виртуальная функция.

* Имеет вид:

  | Вид функции | Адрес |
  | ----------- | ----- |
  | `void f()`  | 0x... |

* Для *класса-наследника* заводится отдельная виртуальная функция. В нем есть функции как из *класса-родителя*, так и новые <u>виртуальные</u>, которые реализованы только в этом классе.
* В классах с виртуальными методами дополнительно есть указатель на *таблицу виртуальных функций* (занимает доп. 8 байт). В памяти он записывается прямо перед теми данными, которые отведены на конкретный экземпляр класса и указывает на *табл. вирт. функц.* (*ТВФ*) соотв. класса.
  * Указатель на *ТВФ* **помогает определить**, **какой тип** объекта **лежит под указателем**.
  * **Замедляет работу**, т.к. необходимо сначала перейти по указателю в табл., потом в табл. найти нужную функцию, перейти по указателю на нее, и только потом выполнить.